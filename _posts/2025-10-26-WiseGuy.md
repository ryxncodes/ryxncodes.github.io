---
title: WiseGuy
date: 2025-10-26 01:37:55 -8000
categories: [THM, machine]
tags: [ctf, thm, crypt, xor, plaintext]     # TAG names should always be lowercase
---

- **Room:** W1seGuy
    
- **IP:** 10.201.31.232
    
- **Tags:** #ctf #tryhackme #crypto #xor #known-plaintext
    

## 1. Enumeration

The instructions noted port `1337` was listening.

##### Provided source code:
```python
import random
import socketserver 
import socket, os
import string

flag = open('flag.txt','r').read().strip()

def send_message(server, message):
    enc = message.encode()
    server.send(enc)

def setup(server, key):
    flag = 'THM{thisisafakeflag}' 
    xored = ""

    for i in range(0,len(flag)):
        xored += chr(ord(flag[i]) ^ ord(key[i%len(key)]))

    hex_encoded = xored.encode().hex()
    return hex_encoded

def start(server):
    res = ''.join(random.choices(string.ascii_letters + string.digits, k=5))
    key = str(res)
    hex_encoded = setup(server, key)
    send_message(server, "This XOR encoded text has flag 1: " + hex_encoded + "\n")
    
    send_message(server,"What is the encryption key? ")
    key_answer = server.recv(4096).decode().strip()

    try:
        if key_answer == key:
            send_message(server, "Congrats! That is the correct key! Here is flag 2: " + flag + "\n")
            server.close()
        else:
            send_message(server, 'Close but no cigar' + "\n")
            server.close()
    except:
        send_message(server, "Something went wrong. Please try again. :)\n")
        server.close()

class RequestHandler(socketserver.BaseRequestHandler):
    def handle(self):
        start(self.request)

if __name__ == '__main__':
    socketserver.ThreadingTCPServer.allow_reuse_address = True
    server = socketserver.ThreadingTCPServer(('0.0.0.0', 1337), RequestHandler)
    server.serve_forever()
```
#### NetCat

Connecting to the port with `netcat` gives us the primary challenge: an XOR-encrypted flag.

**Command:**

```bash
nc 10.201.31.232 1337
```

**Results:**

```bash
This XOR encoded text has flag 1: 643b06133e011227063a750b3f293a444728032d711d395b2f5c3f32001b420732583b420b041a33
What is the encryption key?
```

## 2. Exploitation (Breaking the XOR)

This is a classic repeating-key XOR cipher. The server's source code (provided in the room) reveals two critical weaknesses:

1. The key is only **5 bytes** long.
    
2. The flag format is known: `THM{...}`.
    

This allows for a **Known Plaintext Attack**.

### 2.1. The Attack Logic

The core principle of XOR is:

Plaintext ⊕ Key = Ciphertext

Which also means:

Plaintext ⊕ Ciphertext = Key

We can leverage this by XORing the parts of the ciphertext where we know the corresponding plaintext.

- **Ciphertext (hex):** `643b0613...` (ends with `...41a33`)
    
- **Known Plaintext:** `THM{` (at the beginning) and `}` (at the end)
    

The ciphertext is 80 hex characters (40 bytes). Since the key is 5 bytes and 40 is a multiple of 5, the first 4 bytes of the flag (`THM{`) are encrypted with the first 4 bytes of the key, and the last byte of the flag (`}`) is encrypted with the 5th (and last) byte of the key.

### 2.2. Automated Key Recovery (Python)

We can find the entire key in one line of Python. The script combines both facts: it XORs the first 4 bytes (`enc_flag[:4]`) with `b'THM{'` and the last byte (`enc_flag[-1]`) with `b'}'` to build the complete key.

**Recovery Script:**

```python
from pwn import xor

enc_flag = bytes.fromhex('643b06133e011227063a750b3f293a444728032d711d395b2f5c3f32001b420732583b420b041a33')

key = xor(enc_flag[:4], b'THM{') + xor(enc_flag[-1], b'}')

print(key)

print(xor(enc_flag, key))
```

**Script Output:**

```
b'0sKhN'
THM{...}
```

## 3. Gaining Access

### 3.1. Flag 1

The first flag is recovered by the Python script in step 2.2.

### 3.2. Flag 2

We get Flag 2 by submitting our discovered key (`0sKhN`) to the live `nc` prompt.

**Command & Results:**

```bash
This XOR encoded text has flag 1: 643b06133e011227063a750b3f293a444728032d711d395b2f5c3f32001b420732583b420b041a33
What is the encryption key? 0sKhN
Congrats! That is the correct key! Here is flag 2: THM{...}
```

## 4. Defensive Measures (Blue Team)

### 4.1. Detection

- **Network Monitoring:** A single, correct guess is hard to detect. However, if the attacker had to brute-force the 5th byte, a defender might see **multiple rapid connections to port 1337 from a single source IP**, indicating a scripting attack.
    
- **Log Analysis:** Analyzing service logs (if any) for repeated failed key submissions followed by a success would also be an indicator.
    

### 4.2. Prevention

The vulnerability has several root causes, each with a fix:

1. **Weak Cipher:** A repeating-key XOR is fundamentally insecure.
    
    - **Fix:** Use a modern, vetted encryption algorithm like **AES-256**. Never roll your own crypto.
        
2. **Short, Reused Key:** A 5-byte key is trivial to brute-force, and its repetition is what allows the attack.
    
    - **Fix:** Use a long, cryptographically secure random key (e.g., 32+ bytes) for _every_ session. Ideally, the key should be at least as long as the plaintext (a One-Time Pad, or OTP).
        
3. **Known Plaintext:** The `THM{...}` format is the fatal flaw.
    
    - **Fix:** Do not use predictable prefixes or suffixes in data that will be encrypted. If a format is required, add the prefix/suffix _after_ decryption.
        
    - **Fix (Alternate):** Add random-length padding _before_ encryption. If the flag was `[random_bytes]THM{...}`, the attacker could not be sure that the 1st byte of ciphertext corresponds to 'T'.
